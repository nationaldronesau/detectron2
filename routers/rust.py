from fastapi import APIRouter, File
from fastapi.responses import FileResponse, Response

import logging
import requests
from starlette.background import BackgroundTasks

from model_inference import perform_inference, perform_inference_url, clean_annotations
from auth import SignatureAuth
from config.constants import SMARTDATA_ENDPOINT

from schemas import *
import json

router = APIRouter()

@router.post("/rust/polygons", tags=["rust"])
async def return_polygons(file: bytes = File(...)):
    """
    Perform inference on an image file
    returns: polygons

    @author Dinis Gokaydin <d.gokaydin@nationaldrones.com>
    """

    logging.info(f"Getting polygons for file")
    img, mask, contours = perform_inference(file)
    return clean_annotations(annotations=contours)


@router.post("/rust/polygons_url", tags=["rust"])
async def return_polygons_url(item: Item):
    """
    Perform inference on an image in a given url
    returns: polygons

    @author Dinis Gokaydin <d.gokaydin@nationaldrones.com>
    """

    logging.info(f"Getting polygons for url")
    img, mask, contours = perform_inference_url(item.url)
    return contours


@router.post('/rust/masked-image', tags=["rust"])
async def return_masked_image(file: bytes = File(...)) -> FileResponse:
    """
    Perform inference on an image
    returns: masked image with rust highlighted

    @author Dinis Gokaydin <d.gokaydin@nationaldrones.com>
    """

    logging.info(f"Getting masked image for file")
    img, mask, contours = perform_inference(file)
    img.save('img.jpg')
    
    return FileResponse('img.jpg')


@router.post("/rust/{dataset_uuid}", tags=["rust"])
async def rust_detection(dataset_uuid: str, image_urls: InspectionViewImages, background_tasks: BackgroundTasks) -> Response:
    """
    Runs rust detection on the supplied dataset's inspection view.
    :param dataset_uuid: dataset in Smartdata that rust detection is being applied to
    :param image_urls: URLs of images to perform detection on
    :param background_tasks: background thread worker to process the images after response
    :return: Http response OK
    @author Conor Brosnan <c.brosnan@nationaldrones.com>
    """
    
    logging.info(f"Detecting rust for dataset_uuid {dataset_uuid}")
    background_tasks.add_task(process_rust_detection, dataset_uuid=dataset_uuid, inspection_view_images=image_urls)
    return Response()


async def process_rust_detection(dataset_uuid: str, inspection_view_images: InspectionViewImages) -> None:
    """
    Processes supplied images with rust detection and saves the results to Smartdata dataset
    :param dataset_uuid: dataset to save the autogenerated annotations to in Smartdata
    :param inspection_view_images: images to process with rust detection
    :return:
    @author Conor Brosnan <c.brosnan@nationaldrones.com>
    """
    inspection_view_annotations = InspectionViewAnnotations(dataset_uuid=dataset_uuid, image_annotations_list=[])
    logging.info(f"Getting rust detection results for dataset_uuid: {dataset_uuid}")

    for image_no, image in enumerate(inspection_view_images.images, start=1):
        logging.info(f"Running rust detection on image {image_no}/{len(inspection_view_images.images)}: {image.url}")
        try:
            _, _, annotations = perform_inference_url(image.url)
            logging.info(f"Total Annotations found = {len(annotations)}")
            logging.debug(f"Annotations found = {annotations}")

            # convert the annotations to a more consistent structure
            converted_annotations = clean_annotations(annotations=annotations)
            # Convert annotations coordinates to leaflet ratio
            for annotation in converted_annotations:
                if len(annotation) > 0:
                    for coord in annotation:
                        ratio = 2250 / image.height
                        temp = coord[0] * ratio
                        coord[0] = 2250 - coord[1] * ratio
                        coord[1] = temp

            if len(annotations) > 0:
                # Call smartdata to add the annotations, this is done per image otherwise the request is too large
                logging.debug(
                    f"Sending {len(converted_annotations)} Rust annotations to smartdata for image {image.url}")
                response = requests.post(f"{SMARTDATA_ENDPOINT}/save_autogenerated_rust_annotations/{image.uuid}/",
                                         data=json.dumps(converted_annotations), auth=SignatureAuth())
                if response.status_code != 200:
                    logging.error(f"Smartdata save annotation response: {response.text}")
                    with open("log_output.html", "w") as file:
                        file.write(response.text)
                logging.info("Rust annotation created in smartdata")
            else:
                logging.debug(f"No rust detected in image {image.url}")
        except Exception as e:
            logging.error(f"Failed get the rust annotations for image "
                          f"{image_no}/{len(inspection_view_images.images)}: {image.url}")
            logging.error(e)

    # Send an email to the user about the rust detection being complete
    response = requests.post(f"{SMARTDATA_ENDPOINT}/send_rust_detection_complete_email/{dataset_uuid}/",
                             inspection_view_annotations.json(), auth=SignatureAuth())
    if response.status_code != 200:
        logging.error(f"Smartdata to sending rust detection complete email to user: {response.text}")
    logging.debug("Smartdata requested to send email to user about rust detection being complete")
    logging.info(f"Completed rust detection for dataset_uuid: {dataset_uuid}")
